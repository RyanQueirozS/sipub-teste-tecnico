package delivery_test

import (
	"fmt"
	"regexp"
	"sipub-test/internal/delivery"
	testhelper "sipub-test/pkg/test_helper"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/stretchr/testify/assert"
)

func TestCreateDelivery(t *testing.T) {
	t.Run("ValidCreate", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("failed to create mock DB: %v", err)
		}
		defer db.Close()

		repo := &delivery.MySQLDeliveryRepository{}
		repo.SetDB(db)

		params := delivery.DeliveryParams{
			IsActive:  testhelper.BoolPointer(true),
			IsDeleted: testhelper.BoolPointer(false),
			UserID:    testhelper.StringPointer("user-123"),
			AddressID: testhelper.StringPointer("address-123"),
		}

		sqlmock.NewRows([]string{"id", "isActive", "isDeleted", "createdAt", "email", "cpf", "name"}).
			AddRow("user-123", true, false, "2025-01-15 12:00:00", "testuser@example.com", "12345678901", "Test User")

		mock.NewRows([]string{"id", "isActive", "isDeleted", "createdAt", "street", "number", "neighborhood", "complement", "city", "state", "country", "latitude", "longitude", "name"}).
			AddRow("address-123", true, false, "2025-01-15 12:00:00", "Main Street", "123", "Downtown", "", "Metropolis", "NY", "USA", 0, 0, "")

		mock.ExpectExec(`INSERT INTO deliveries`).
			WithArgs(sqlmock.AnyArg() /* id generated by function */, true, false, sqlmock.AnyArg() /*time*/, "user-123", "address-123").
			WillReturnResult(sqlmock.NewResult(1, 1))

		delivery, err := repo.Create(params)

		assert.NoError(t, err, "Shouldn't contain any errors")
		assert.Equal(t, *params.IsActive, delivery.ToDTO().IsActive)
		assert.Equal(t, *params.UserID, delivery.ToDTO().UserID)
		assert.Equal(t, *params.AddressID, delivery.ToDTO().AddressID)
	})
}

func TestGetAllDeliveries(t *testing.T) {
	t.Run("ValidGetAll", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("failed to create mock DB: %v", err)
		}
		defer db.Close()

		repo := &delivery.MySQLDeliveryRepository{}
		repo.SetDB(db)

		rows := sqlmock.NewRows([]string{"id", "isActive", "isDeleted", "createdAt", "user_id", "address_id"}).
			AddRow("delivery-123", true, false, "2025-01-15 12:00:00", "user-123", "address-123")

		mock.ExpectQuery(`SELECT id, isActive, isDeleted, createdAt, user_id, address_id FROM deliveries`).
			WillReturnRows(rows)

		filter := delivery.DeliveryParams{}
		deliveries, err := repo.GetAll(filter)

		assert.NoError(t, err, "Should have no errors")
		assert.Len(t, deliveries, 1, "Length should be 1")
		assert.Equal(t, "delivery-123", deliveries[0].ToDTO().Id, "Id should match")
		assert.Equal(t, "user-123", deliveries[0].ToDTO().UserID, "UserID should match")
		assert.Equal(t, "address-123", deliveries[0].ToDTO().AddressID, "AddressID should match")
	})

	t.Run("ShouldReturnAnErrorIfNoDeliveriesFound", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("failed to create mock DB: %v", err)
		}
		defer db.Close()

		repo := &delivery.MySQLDeliveryRepository{}
		repo.SetDB(db)

		mock.ExpectQuery(`SELECT id, isActive, isDeleted, createdAt, user_id, address_id FROM deliveries`).
			WillReturnError(fmt.Errorf("failed to get deliveries"))

		filter := delivery.DeliveryParams{UserID: testhelper.StringPointer("nonexistent-user")}
		deliveries, err := repo.GetAll(filter)

		assert.Error(t, err, "Should have an error")
		assert.Len(t, deliveries, 0, "Length should be 0")
	})
}

func TestGetDeliveryByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock DB: %v", err)
	}
	defer db.Close()

	repo := &delivery.MySQLDeliveryRepository{}
	repo.SetDB(db)

	rows := sqlmock.NewRows([]string{"id", "isActive", "isDeleted", "createdAt", "user_id", "address_id"}).
		AddRow("delivery-123", true, false, "2025-01-15 12:00:00", "user-123", "address-123")

	mock.ExpectQuery(regexp.QuoteMeta(`SELECT id, isActive, isDeleted, createdAt, user_id, address_id FROM deliveries WHERE id = ?`)).
		WithArgs("delivery-123").
		WillReturnRows(rows)

	delivery, err := repo.GetOne("delivery-123")

	assert.NoError(t, err, "Should have no errors")
	assert.Equal(t, "delivery-123", delivery.ToDTO().Id, "ID should match")
	assert.Equal(t, "user-123", delivery.ToDTO().UserID, "UserID should match")
	assert.Equal(t, "address-123", delivery.ToDTO().AddressID, "AddressID should match")
}

func TestDeleteDelivery(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock DB: %v", err)
	}
	defer db.Close()

	repo := &delivery.MySQLDeliveryRepository{}
	repo.SetDB(db)

	mock.ExpectExec(`DELETE FROM deliveries WHERE id = ?`).
		WithArgs("delivery-123").
		WillReturnResult(sqlmock.NewResult(1, 1))

	count, err := repo.DeleteOne("delivery-123")

	assert.NoError(t, err)
	assert.Equal(t, uint(1), count, "1 row should be affected")
}

func TestUpdateDelivery(t *testing.T) {
	t.Run("ValidUpdate", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("failed to create mock DB: %v", err)
		}
		defer db.Close()

		repo := &delivery.MySQLDeliveryRepository{}
		repo.SetDB(db)

		existingRows := sqlmock.NewRows([]string{"id", "isActive", "isDeleted", "createdAt", "user_id", "address_id"}).
			AddRow("delivery-123", true, false, "2025-01-15 12:00:00", "user-123", "address-123")

		mock.ExpectQuery(`SELECT id, isActive, isDeleted, createdAt, user_id, address_id FROM deliveries WHERE id = ?`).
			WithArgs("delivery-123").
			WillReturnRows(existingRows)

		newParams := delivery.DeliveryParams{
			IsActive:  testhelper.BoolPointer(false),
			AddressID: testhelper.StringPointer("new-address-123"),
		}

		mock.ExpectExec(regexp.QuoteMeta(`UPDATE deliveries SET isActive = ?, isDeleted = ?, address_id = ? WHERE id = ?`)).
			WithArgs(false, false, "new-address-123", "delivery-123").
			WillReturnResult(sqlmock.NewResult(1, 1))

		updatedRows := sqlmock.NewRows([]string{"id", "isActive", "isDeleted", "createdAt", "user_id", "address_id"}).
			AddRow("delivery-123", false, false, "2025-01-15 12:00:00", "user-123", "new-address-123")

		mock.ExpectQuery(`SELECT id, isActive, isDeleted, createdAt, user_id, address_id FROM deliveries WHERE id = ?`).
			WithArgs("delivery-123").
			WillReturnRows(updatedRows)

		delivery, err := repo.Update("delivery-123", newParams)

		assert.NoError(t, err)
		assert.Equal(t, "delivery-123", delivery.ToDTO().Id, "ID should match")
		assert.Equal(t, "new-address-123", delivery.ToDTO().AddressID, "AddressID should match updated value")
		assert.Equal(t, false, delivery.ToDTO().IsActive, "IsActive should match updated value")
	})
}
